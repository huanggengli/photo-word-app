export default async function compressImage(file: File, options?: { maxWidth?: number; quality?: number }): Promise<File> { const maxWidth = options?.maxWidth ?? 1024; const quality = options?.quality ?? 0.7; const dataUrl = await new Promise<string>((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result as string); reader.onerror = (e) => reject(e); reader.readAsDataURL(file); }); const img = await new Promise<HTMLImageElement>((resolve, reject) => { const image = new Image(); image.onload = () => resolve(image); image.onerror = (e) => reject(e); image.src = dataUrl; }); const originWidth = img.width; const originHeight = img.height; let targetWidth = originWidth; let targetHeight = originHeight; if (originWidth > maxWidth) { targetWidth = maxWidth; targetHeight = Math.round((originHeight * maxWidth) / originWidth); } const canvas = document.createElement("canvas"); canvas.width = targetWidth; canvas.height = targetHeight; const ctx = canvas.getContext("2d"); if (!ctx) { throw new Error("无法创建画布上下文"); } ctx.drawImage(img, 0, 0, targetWidth, targetHeight); const blob: Blob = await new Promise((resolve, reject) => { canvas.toBlob((b) => { if (!b) { reject(new Error("压缩失败，未生成图像")); return; } resolve(b); }, "image/jpeg", quality); }); const compressedFile = new File([blob], (file.name ? file.name.replace(/\.[^.]+$/, "") : "compressed") + ".jpg", { type: "image/jpeg" }); return compressedFile; }